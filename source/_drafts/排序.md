总结一下排序算法。

# 数组

以leetcode 912作测试。这个题目就是让排序一个数组，有如下前提条件：

>- `1 <= nums.length <= 50000`
>- `-50000 <= nums[i] <= 50000`

## 桶排

这是O(N)的排序算法，优点是快，空间换时间，缺点是需要知道给定数据的范围，而且这个范围不能过大。

```c++
vector<int> sortArray(vector<int>& nums) {
    vector<int> buckets(100001);
    vector<int> res;
    res.reserve(nums.size());
    for(int val : nums)
    {
        buckets[val+50000]++;
    }
    for(int i = 0; i < buckets.size();)
    {
        if(buckets[i])
        {
            res.push_back(i-50000);
            buckets[i]--;
        }
        else
            ++i;
    }
    return res;
}
```

## 快排

```c++
int Patition(vector<int>& nums, int s, int e)
{
    int pivot = nums[e];
    int m = s-1;
    for(int i = s; i < e; ++i)
    {
        if(nums[i]<=pivot)
        {
            ++m;
            swap(nums[m], nums[i]);
        }
    }
    ++m;
    swap(nums[m], nums[e]);
    return m;
}
void QuickSortImpl(vector<int>& nums, int s, int e)
{
    if(s>=e)
        return;
    int m = Patition(nums, s, e);
    QuickSortImpl(nums, s, m-1);
    QuickSortImpl(nums, m+1, e);
}

void QuickSort(vector<int>& nums)
{
	QuickSortImpl(nums, 0, nums.size()-1);
}
```

优化：Patition函数在选择pivot时，随机选择一个数作为pivot，而不是直接使用开头或者结尾的数作为pivot。

```c++
int Patition(vector<int>& nums, int s, int e)
{
    int m = s-1;
    int index = s+rand()%(e-s+1);
    //将pivot放到结尾位置
    swap(nums[index], nums[e]);
    int pivot = nums[e];
    for(int i = s; i < e; ++i)
    {
        if(nums[i]<=pivot)
        {
            ++m;
            swap(nums[m], nums[i]);
        }
    }
    //将pivot置于数组分界点上
    ++m;
    swap(nums[m], nums[e]);
    return m;
}
```

另一种方式是把pivot放到数组开头：

```c++
int Patition(vector<int>& nums, int s, int e)
{
    int m = s;
    int index = s+rand()%(e-s+1);
    //将pivot置于数组开头
    swap(nums[index], nums[s]);
    int pivot = nums[s];
    for(int i = s+1; i <= e; ++i)
    {
        if(nums[i]<=pivot)
        {
            ++m;
            swap(nums[m], nums[i]);
        }
    }
    //将pivot置于数组分界点上，注意，这里的m不用自增
    swap(nums[m], nums[s]);
    return m;
}
```

无论上面哪种写法，都要在最后将pivot置于数组分界点上，这是因为在QuickSort的递归中，分界点不参与下次递归过程，因此必须保证分界点上的数是pivot，否则排序会出错。

将pivot置于开头还是结束，其实影响不大，在leetcode912的测试中，置于结束位置反而效果更好一些。理论上而言，二者的速度相同，可能是cache的原因。以全冷的cache为例，放在结尾的话，在放pivot的时候会有一次cache miss，在遍历开始的时候有一次cache miss， 在将pivot放置在分界点上时没有；放在开头的话，放pivot虽然也有cache miss，后续的遍历过程没有，将pivot放置在分界点上时有。

这里只给出了单边遍历的patition，双边遍历更麻烦一些，而且得想清楚分界点是左边指针还是右边指针。单边遍历的话，不仅适用于数组，也适用于链表。

## 归并

```c++
void Merge(vector<int>& nums, int s, int m, int e, vector<int> & buf)
{
    int k = s;
    int i = s, j = m+1;
    while(i<=m && j<=e)
    {
        if(nums[i] <= nums[j])
            buf[k++] = nums[i++];
        else
            buf[k++] = nums[j++];
    }
    while(i<=m)
        buf[k++] = nums[i++];
    while(j<=e)
        buf[k++] = nums[j++];
    copy(buf.begin()+s, buf.begin()+e+1, nums.begin()+s);
}
void MergeSortImpl(vector<int>& nums, int s, int e, vector<int> & buf)
{
    if(s>=e)
        return;
    int m = s+(e-s)/2;
    MergeSortImpl(nums, s, m, buf);
    MergeSortImpl(nums, m+1, e, buf);
    Merge(nums, s, m, e, buf);
}
void MergeSort(vector<int>& nums)
{
    vector<int> buf(nums.size());
    MergeSortImpl(nums, 0, nums.size()-1, buf);
}
```

归并需要注意在merge时小心处理边界。另外，用于merge的buf最好一开始就分配好，每次用的时候来分配的话会在堆上有多余开销。

## 堆排

堆排序的思路在于不断地从堆顶取出最大值，放到数组尾部后。堆排序用的是完全二叉树，所以对于一个父亲节点parent，它的左儿子节点为`2*parent+1`，右儿子节点为`2*parent+2`。另外，对于一个大小为N的数组来说，它的最后一个父亲节点的索引为`(N-2)/2`。

根据这些条件，可以写出一版简陋但是还能work的heap sort。

```c++
void GotMax(vector<int>& nums, int parent, int leftSon, int rightSon, int & pos, int N)
{
    pos = 0;
    int Mx = nums[parent];
    if (leftSon < N && Mx < nums[leftSon])
    {
        Mx = nums[leftSon];
        pos = 1;
    }
    if (rightSon < N && Mx < nums[rightSon])
    {
        pos = 2;
    }
}
void Adjust(vector<int>& nums, int parent, int N)
{
    while (parent < N)
    {
        int leftSon = parent * 2 + 1;
        int rightSon = parent * 2 + 2;
        int MaxPos;
        GotMax(nums, parent, leftSon, rightSon, MaxPos, N);
        if (MaxPos == 0)
            break;
        else if (MaxPos == 1)
        {
            swap(nums[parent], nums[leftSon]);
            parent = leftSon;
        }
        else
        {
            swap(nums[parent], nums[rightSon]);
            parent = rightSon;
        }
    }
}
void setUpHeap(vector<int>& nums)
{
    int N = nums.size();
    int lastParent = (N-2) / 2;
    for (int i = lastParent; i >= 0; --i)
    {
        Adjust(nums, i, N);
    }
}

void heapSort(vector<int> & nums)
{
    setUpHeap(nums);
    int N = nums.size();
    while (N)
    {
        swap(nums[0], nums[N - 1]);
        N--;
        Adjust(nums, 0, N);
    }
}
```

核心在于Ajdust函数。堆排的实现思路如下：

- 对于一个混乱的数组，首先将其调整为大顶堆(maxheap)
- 接下来，不断将大顶堆的堆顶元素与堆的尾部进行交换，然后调整大顶堆，堆的大小也随之减少一，直到堆没有元素位置。

不论是将数组调整为大顶堆，还是在大顶堆的堆顶元素弹出后，都需要调用Adjust函数进行调整。在上面的代码中，Adjust函数以parent为核心进行循环调整，导致代码较为丑陋。如果以左儿子为核心，代码就比较优雅了。

```c++
void Adjust(vector<int>& nums, int parent, int N)
{
	int leftSon = parent * 2 + 1;
	while (leftSon < N)
	{
		if (leftSon + 1 < N && nums[leftSon] < nums[leftSon + 1])
			leftSon++;
		if (nums[parent] < nums[leftSon])
		{
			swap(nums[parent], nums[leftSon]);
			parent = leftSon;
			leftSon = parent * 2 + 1;
		}
		else
			break;
	}
}
```

上面的代码中，第二个if语句其实可以把`else break`提到前面来，但是我并没有如此做，这是因为我希望通过if语句中小于判断提醒一下，排序是基于严格小于进行的。如果将`else break`提到前面，那么务必写`>=`或者`!(xxx < XXX)`。

接下来，还能进行的优化是避免每次都使用swap。

```c++
void Adjust(vector<int>& nums, int hole, int val, int N)
{
	int leftSon = hole * 2 + 1;
	while (leftSon < N)
	{
		if (leftSon + 1 < N && nums[leftSon] < nums[leftSon + 1])
			leftSon++;
		if (val < nums[leftSon])
		{
			nums[hole] = nums[leftSon];
			hole = leftSon;
			leftSon = hole * 2 + 1;
		}
		else
			break;
	}
	nums[hole] = val;
}
void setUpHeap(vector<int>& nums)
{
	int N = nums.size();
	int lastParent = (N-2) / 2;
	for (int i = lastParent; i >= 0; --i)
	{
		Adjust(nums, i, nums[i], N);
	}
}

void heapSort(vector<int> & nums)
{
	setUpHeap(nums);
	int N = nums.size();
	while (N)
	{
		int val = nums[N - 1];
		nums[N - 1] = nums[0];
		N--;
		Adjust(nums, 0, val, N);
	}
}
```

为了避免swap，需要做几个事情

- 修改Adjust函数
  1. 它现在接受的参数不叫parent，而叫做hole了。
  2. 它的参数中多了一个在调整结束后hole所在位置应该存放的值val。在setUpHeap函数中，这个值就是hole位置上的值。
  3. 它在每次调整时仅用儿子的值覆盖父亲的值，而不是使用交换。作为收尾，在循环结束后，需要将val放置到hole位置上去。
- 在heapSort函数弹出堆顶元素时，也需要将swap进行相应的替换。

本小节的堆排序参考了一篇[博客](https://blog.csdn.net/caroline_wendy/article/details/31357053)

## 冒泡

## 插入

## 选择

## stl的sort

两个知识点：

- stl的sort是不稳定的
- 相比c标准库的qsort，stl的sort是综合了多种排序方式，而且能够内联展开比较函数。

以libstdc++的sort源码为参考，影响stl的sort方式的两个因素分别是数组的长度N和递归深度depth，其中，N的下限是16， depth的上限是log2（N）*2.

排序算法如下：

- 首先，按照快排的方式递归向下
  - 若当前数组范围长度N小于16，直接返回
  - 否则，若当前递归深度depth超过了上限，则将当前数组范围内的所有元素进行堆排。
- 现在，数组大部分是有序的了，对数组进行一次插入排序。

## stl的stable_sort(TIM sort)



带buffer的merge：相比本文的归并，进行了更多的优化。具体有以下几点：

- 用循环替代递归，避免递归层次过深而导致的爆栈问题。具体而言，就是每step_size大小为一组，进行一次merge，将数组的所有组处理完毕后，step_size二倍增长，再次划分为若干组进行merge，循环往复，直到整个数组merge完毕
- 最开始时step_size大小为7，对这7个数使用插入排序使其有序，而不是用归并排序处理。
- 一次归并完成后，数据被复制到了buffer上。此时，不是把buffer的数据复制回原数组后再进行merge，而是二倍增长step_size后直接在buffer上进行归并，将归并后的结果拷贝到原数组。也就是说，要经历两次归并，数据才会回到原数组上。

# 链表

以leetcode 148作测试。

## 快排

## 归并

## 插入



# 与排序算法有关联的算法

## kth_element

## 多路归并

## 逆序对